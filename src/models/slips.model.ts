import { NoSqlClient } from "@db/nosql.client";
import { Model } from "@models/model";
import { IError, ErrorTypes } from "@lib/error.interface";
import { isError } from "util";
import { IBoatResult, BoatsModel } from "@models/boats.model";
import { Query } from "@google-cloud/datastore";

export interface ISlip {
    /** id: string, */      // autogenerated
    number: number,         // slip number (human readable unique identifier)
    current_boat: string,   // id of current boat, null if empty
    arrival_date: string,   // date the current boat arrived
}

export interface ISlipResult {
    // TODO: implement this interface
    //      data, live link, boat link
    number: number,
    current_boat: string,
    arrival_date: string,
    link: string
    boat_link: string
}

export const SLIPS = "slips";

export class SlipsModel extends Model {
    private static _instance: SlipsModel;
    public static get Instance(): SlipsModel {
        if (!this._instance) this._instance = new SlipsModel();
        return this._instance;
    }

    protected nosqlClient: NoSqlClient;
    private boatsModelRef: BoatsModel;

    constructor() { 
        super();
        this.nosqlClient = NoSqlClient.Instance;

        this.boatsModelRef = BoatsModel.Instance;
        this.boatsModelRef.registerDeleteCallback(this.handleBoatDeleted)

        console.log("SlipsModel initialized");
    }

    public async numberUnique(_testNumber: number): Promise<boolean> {
        /** get all numbers */
        let allSlips = await this.getAllSlips() as ISlipResult[];
        if (!isError(allSlips)) {
            /** check against each number */
            for (let slip of allSlips) {
                // TODO: make sure number accessor correct
                if (_testNumber == slip.number) {
                    return false;
                }
            }
        }

        /** number is unique */
        return true;
    }

    public confirmInterface(obj: any): boolean {
        /** only number will be supplied when creating a new slip */
        if (!("number" in obj) || !(typeof obj.number == "number")) {
            return false;
        } else return true;
    }

    public slipExistsById(_id: string): Promise<boolean> {
        return this.getSlipById(_id).then((result) => {
            if (!isError(result)) return true;
            return false;
        })
    }

    public async retrieveIdFromSlip(slipData: ISlip): Promise<string> {
        // TODO: test this
        return this.nosqlClient.getIdFromData(slipData);
    }

    public async getSlipByNumber(slipNumber: number): Promise<any> {
        const query: Query = this.nosqlClient.datastore.createQuery(SLIPS)
            .filter("number", "=", slipNumber);
        return await this.nosqlClient.runQueryForModel(query);
    }

    public async getSlipById(slipId: string): Promise<ISlipResult | IError> {
        // TODO: build slip results (add links, etc...)
        return await this.nosqlClient.datastoreGetById(SLIPS, slipId);
    }

    public async getAllSlips(): Promise<ISlipResult[] | IError> {
        // TODO: build slip results (add links, etc...)
        return await this.nosqlClient.datastoreGetCollection(SLIPS);
    }

    public async createSlip(_number: number): Promise<any> {
        const newSlip: ISlip = {
            number: _number,
            current_boat: null,
            arrival_date: null      
        }
        return await this.nosqlClient.datastoreSave(SLIPS, newSlip);
    }

    public async deleteSlip(slipId: string): Promise<any> {
        return this.nosqlClient.datastoreDelete(SLIPS, slipId);
    }

    public async editSlip(slipId: string, editSlip: Partial<ISlip>) {
        if (this.slipExistsById(slipId)) {
            return this.nosqlClient.datastoreEdit(SLIPS, slipId, editSlip);
        } else return <IError>{ error_type: ErrorTypes.DOESNT_EXIST }
    }

    public async dockBoatAtSlip(slipId: string, boatId: string)
        : Promise<any> {
        // TODO: A boat should be able to arrive and be assigned a slip number specified 
        //  in the request (no automatically assigning boats to slips)

        // TODO: make sure this is ok
        const date: string = (new Date).toString();

        // TODO: validate here
        //  - slip is not occupied
        //  - handle case where boat is docked somewhere else
        // TODO: If the slip is occupied the server should return an Error 403 Forbidden message
        //  This will require knowing the slip, date of arrival and boat

        return this.editSlip(slipId, {
            current_boat: boatId,
            arrival_date: date
        });        
    }

    public async evacuateFromSlip(slipId: string, boatId: string)
        : Promise<any | IError> {
        let slip = await this.getSlipById(slipId) as ISlipResult;
        if (!isError(slip)) {
            let boat = await this.boatsModelRef.getBoatById(boatId) as IBoatResult;
            if (!isError(boat)) {
                if (slip.current_boat == boat.name)
                return this.editSlip(slipId, {
                    current_boat: null
                });
            }
        }
        return <IError>{ error_type: ErrorTypes.DOESNT_EXIST }
    }

    private async evacuateSlip(slipId: string): Promise<any> {
        return this.editSlip(slipId, {
            current_boat: null
        });
    }

    private async handleBoatDeleted(boatId: string): Promise<any | IError> {
        let allSlips = await this.getAllSlips() as ISlipResult[];
        if (!isError(allSlips)) {
            for (let slip of allSlips) {
                if (slip.current_boat == boatId) {
                    let slipId = await this.nosqlClient.getIdFromData(slip)
                    this.evacuateSlip(slipId);
                }
            }
        } else {
            let error = allSlips; 
            return allSlips;
        }
    }
}
